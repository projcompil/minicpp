I/ Le lexer

Ici la casse est significative. On utilise maintenant la Hashtbl h, pour trouver les mots clés.
Le lexer hack se trouve maintenant dans lexerhack.ml.

La fonction chaine permet de traiter correctement les chaînes de caractères du C++ en faisant attention aux caractères d'échappement.


II/ L'arbre de syntaxe abstraite

On est resté proche de la grammaire du sujet pour faire l'arbre de syntaxe abstraite.
Les arbres de syntaxe abstraite sont maintenant décorés (via le type polymorphe pos).

III/ Le parser

On a réglé la plupart des conflits par l'utilisation de règles de précédence. (IFX et LPAR)
On a bien fait attention à enregistrer dans la table du lexer hack l'identifiant de la classe déclarée avant de traiter ses membres (par exemple on déclare dans un ABR des attributs de type ABR).

IV/ Le lexer hack

Le lexer hack consiste simplement en une Hashtbl dans un module séparé, afin de différencier identifiants de type et les autres identifiants.


V/ Typage

On transforme les arbres de syntaxe abstraites en ajoutant les types pour les expressions, ajoutant d'autres informations pour les identifiants.

On utilise de nombreuses tables de hachage pour mémoriser des informations utiles.

On stocke dans l'environnement le type de retour des fonctions, en ajoutant la chaîne chtypereturn = "@typereturn" en clé et le type en champ, afin de pouvoir renvoyer une erreur de typage lorsqu'un return de la fonction renvoie un type qui n'est pas un sous-type du type de la fonction.

VI/ Production de code

On a bien fait attention à rendre les opérateurs && et || paresseux (via un saut conditionnel).
